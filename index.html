<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A step tracking visualization for 2026 with interactive heatmap display, daily totals, walking distance, activity streaks, and personal records.">
    <meta name="theme-color" content="#0d1117">

    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" type="image/svg+xml" href="favicon.svg">

    <!-- Open Graph / Social Media -->
    <meta property="og:title" content="Step Tracker 2026">
    <meta property="og:description" content="A step tracking visualization for 2026 with interactive heatmap display and activity statistics.">
    <meta property="og:type" content="website">

    <title>Step Tracker 2026</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/plugin/utc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/plugin/timezone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cal-heatmap@4.2.4/dist/cal-heatmap.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cal-heatmap@4.2.4/dist/cal-heatmap.css">
    <script src="https://cdn.jsdelivr.net/npm/cal-heatmap@4.2.4/dist/plugins/CalendarLabel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script>
        // Skip GoatCounter tracking for development environments
        if (window.location.hostname === 'localhost' || 
            window.location.hostname === '127.0.0.1' || 
            window.location.hostname.includes('192.168.') ||
            window.location.hostname.includes('10.0.') ||
            window.location.hash === '#toggle-goatcounter') {
            window.goatcounter = {no_onload: true};
        }
    </script>
    <script data-goatcounter="https://normal-past.goatcounter.com/count"
            async src="//gc.zgo.at/count.js"></script>
    <script src="./config.js?v=1767921760"></script>
    <style>
        /* ========================================================================
           BASE LAYOUT & TYPOGRAPHY
           ======================================================================== */
        body {
            font-family: system-ui, sans-serif;
            background: #0d1117;
            color: #c9d1d9;
            margin: 0;
            padding: 20px;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            text-align: center;
        }
        .stats { display: inline-flex; gap: 30px; justify-content: center; margin: 20px 0; opacity: 0; transition: opacity 0.5s ease-in; }
        .stats.loaded { opacity: 1; }
        .stat { font-size: 24px; font-weight: bold; }
        .label { font-size: 12px; color: #8b949e; }
        #cal-heatmap { margin: 20px 0; opacity: 0; transition: opacity 0.6s ease-in; }
        #cal-heatmap.loaded { opacity: 1; }

        /* Add breathing room so SVG strokes (e.g., max-day outline) don't get clipped at edges */
        #cal-heatmap svg {
            overflow: visible;
        }
        /* Cal-Heatmap positions content tightly; this wrapper padding helps first/last column strokes */
        #cal-heatmap {
            padding: 3px;
            margin: 17px auto; /* keep roughly the same visual spacing as 20px */
            display: inline-block;
        }

        /* SVG-friendly highlight for the max-step day (box-shadow doesn't apply to SVG rects) */
        #cal-heatmap rect.is-max-day {
            stroke: #ffd700;
            stroke-width: 2px;
            /* ensure stroke is drawn clearly on top of the fill */
            paint-order: stroke;
            /* keep stroke sizing stable */
            vector-effect: non-scaling-stroke;
        }

        /* Visual tap feedback for mobile interactions */
        #cal-heatmap rect.ch-subdomain-bg {
            cursor: pointer;
            transition: opacity 0.15s ease;
        }

        /* Active state for touch devices - provides immediate visual feedback */
        #cal-heatmap rect.ch-subdomain-bg:active {
            opacity: 0.7;
        }

        /* Hover state for desktop (doesn't interfere with mobile) */
        @media (hover: hover) and (pointer: fine) {
            #cal-heatmap rect.ch-subdomain-bg:hover {
                opacity: 0.85;
            }
        }

        /* Custom tooltip (more reliable than SVG <title> tooltips across browsers) */
        #step-tooltip {
            position: fixed;
            z-index: 9999;
            pointer-events: none;
            display: none;
            max-width: 320px;
            min-width: 200px;
            border: 1px solid #30363d;
            border-radius: 8px;
            background: #161b22;
            color: #c9d1d9;
            font-size: 12px;
            line-height: 1.5;
            box-shadow: 0 8px 24px rgba(0,0,0,0.45);
            overflow: hidden;
        }

        /* Mobile tooltip adjustments */
        @media (max-width: 768px) {
            #step-tooltip {
                max-width: calc(100vw - 32px); /* Leave 16px padding on each side */
                min-width: 180px;
            }
        }

        @media (max-width: 480px) {
            #step-tooltip {
                max-width: calc(100vw - 24px); /* Leave 12px padding on each side */
                min-width: 160px;
                font-size: 11px;
            }
        }

        /* StatsCard components */
        .stats-card-header {
            padding: 10px 12px 8px;
            border-bottom: 1px solid #21262d;
            font-weight: 600;
            font-size: 13px;
            color: #e6edf3;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stats-card-header svg {
            width: 16px;
            height: 16px;
            stroke-width: 2;
        }

        .stats-card-body {
            padding: 8px 12px;
        }

        .stats-card-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            gap: 16px;
        }

        .stats-card-row:not(:last-child) {
            border-bottom: 1px solid #21262d;
        }

        .stats-card-label {
            color: #8b949e;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stats-card-value {
            color: #e6edf3;
            font-weight: 600;
            font-size: 13px;
            text-align: right;
        }

        .stats-card-icon {
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }

        .stats-card-icon svg {
            width: 14px;
            height: 14px;
            stroke-width: 2;
        }

        .stats-card-footer {
            padding: 8px 12px;
            border-top: 1px solid #21262d;
            font-size: 11px;
            color: #8b949e;
            text-align: center;
        }

        .stats-card-simple {
            padding: 10px 12px;
        }

        /* Legend styling */
        .legend {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            margin-top: 10px;
            font-size: 12px;
            opacity: 0;
            transition: opacity 0.6s ease-in;
        }

        .legend.loaded {
            opacity: 1;
        }

        .legend-text {
            color: #768390;
        }

        .legend-colors {
            display: flex;
            gap: 2px;
        }

        .legend-box {
            width: 10px;
            height: 10px;
            border-radius: 1px;
        }

        /* Loading skeleton */
        .loading-skeleton {
            display: block;
            margin: 20px auto;
            padding: 3px;
        }

        .loading-skeleton.hidden {
            display: none;
        }

        .skeleton-grid {
            display: grid;
            grid-template-columns: repeat(7, 11px);
            gap: 4px;
            margin: 0 auto;
            width: fit-content;
        }

        .skeleton-month {
            display: inline-block;
            margin: 0 2px;
        }

        .skeleton-cell {
            width: 11px;
            height: 11px;
            background: #161b22;
            border-radius: 2px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        /* Responsive skeleton cells to match heatmap sizing */
        @media (max-width: 768px) {
            .skeleton-grid {
                grid-template-columns: repeat(7, 15px);
            }
            .skeleton-cell {
                width: 15px;
                height: 15px;
            }
        }

        @media (max-width: 480px) {
            .skeleton-grid {
                grid-template-columns: repeat(7, 18px);
                gap: 5px;
            }
            .skeleton-cell {
                width: 18px;
                height: 18px;
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 0.7; }
        }

        /* Last updated timestamp styling */
        .last-updated {
            opacity: 0;
            transition: opacity 0.6s ease-in;
        }

        .last-updated.loaded {
            opacity: 1;
        }

        /* ========================================================================
           RESPONSIVE MOBILE / PORTRAIT STYLES
           ======================================================================== */

        /* Wrapper for horizontal scroll on mobile */
        .heatmap-wrapper {
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch; /* smooth scrolling on iOS */
            margin: 17px 0;
        }

        /* Mobile portrait optimization */
        @media (max-width: 768px) {
            body {
                padding: 15px 10px;
            }

            .container {
                max-width: 100%;
            }

            /* 2x2 grid layout on narrow screens */
            .stats {
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                gap: 15px;
                max-width: 400px;
            }

            /* Ensure heatmap container scrolls horizontally */
            .heatmap-wrapper {
                width: 100%;
                margin: 17px -10px; /* extend to edges */
                padding: 0 10px;
            }

            #cal-heatmap {
                margin: 0 auto;
            }
        }

        /* Extra small screens - reduce cell size slightly */
        @media (max-width: 480px) {
            body {
                padding: 10px 5px;
            }

            .stats {
                gap: 15px;
            }

            .stat {
                font-size: 20px;
            }

            .label {
                font-size: 11px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
              
        <div class="stats">
            <div>
                <div class="stat" id="total-steps">-</div>
                <div class="label">Total Steps</div>
            </div>
            <div>
                <div class="stat" id="daily-average">-</div>
                <div class="label">Daily Average</div>
            </div>
            <div>
                <div class="stat" id="current-streak">-</div>
                <div class="label">10k+ Streak</div>
            </div>
            <div>
                <div class="stat" id="goal-percentage">-</div>
                <div class="label">Adherence Score</div>
            </div>
        </div>

        <!-- Loading skeleton -->
        <div id="loading-skeleton" class="loading-skeleton">
            <div style="display: flex; gap: 8px; justify-content: center; flex-wrap: wrap;">
                <div class="skeleton-month">
                    <div class="skeleton-grid">
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                    </div>
                </div>
                <div class="skeleton-month">
                    <div class="skeleton-grid">
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                    </div>
                </div>
                <div class="skeleton-month">
                    <div class="skeleton-grid">
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                        <div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div><div class="skeleton-cell"></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="heatmap-wrapper">
            <div id="cal-heatmap"></div>
        </div>

        <div class="legend">
            <span class="legend-text">0</span>
            <div class="legend-colors">
                <div class="legend-box" style="background-color: #14432a;"></div>
                <div class="legend-box" style="background-color: #166b34;"></div>
                <div class="legend-box" style="background-color: #37a446;"></div>
                <div class="legend-box" style="background-color: #4dd05a;"></div>
            </div>
            <span class="legend-text">10k+</span>
        </div>

        <div class="label last-updated" id="last-updated" style="margin-top: 15px;">Last updated: -</div>
    </div>

    <div id="step-tooltip" role="tooltip" aria-hidden="true"></div>

    <script>
        // ============================================================================
        // INITIALIZATION & UTILITIES
        // ============================================================================
        dayjs.extend(dayjs_plugin_utc);
        dayjs.extend(dayjs_plugin_timezone);

        const cal = new CalHeatmap();

        /**
         * Get responsive cell dimensions based on screen width
         * @returns {Object} Cell configuration with width, height, and gutter
         */
        const getResponsiveCellConfig = () => {
            const width = window.innerWidth;

            // Mobile phones (≤480px): Larger cells for easier tapping
            if (width <= 480) {
                return { width: 18, height: 18, gutter: 5 };
            }
            // Tablets (≤768px): Medium cells
            else if (width <= 768) {
                return { width: 15, height: 15, gutter: 4 };
            }
            // Desktop: Standard cells
            else {
                return { width: 11, height: 11, gutter: 4 };
            }
        };

        /**
         * Format number with commas for readability
         * @param {number} n - Number to format
         * @returns {string} Formatted number string
         */
        const fmt = (n) => n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");

        /**
         * Render a Lucide icon by name
         * @param {string} iconName - Name of the Lucide icon (e.g., 'trophy', 'map-pin')
         * @returns {string} HTML string for the icon
         */
        const renderIcon = (iconName) => {
            return `<i data-lucide="${iconName}"></i>`;
        };
        
        /**
         * Safe error handling wrapper for async operations
         * @param {Function} fn - Function to execute
         * @param {string} context - Context for error logging
         */
        const safeExecute = async (fn, context = 'operation') => {
            try {
                return await fn();
            } catch (error) {
                console.error(`Error in ${context}:`, error);
                return null;
            }
        };

        /**
         * Render a reusable stats card for tooltips
         * @param {Object} config - Configuration object
         * @param {string} config.title - Optional header title
         * @param {string} config.titleIcon - Optional icon name for the title
         * @param {Array} config.stats - Array of stat objects {label, value, icon}
         * @param {string} config.footer - Optional footer text
         * @param {string} config.simple - Optional simple text for basic tooltips
         * @returns {string} HTML string for the stats card
         */
        const renderStatsCard = (config) => {
            // Simple mode: just render plain text with padding
            if (config.simple) {
                return `<div class="stats-card-simple">${config.simple}</div>`;
            }

            let html = '';

            // Header
            if (config.title) {
                let titleContent = config.title;
                if (config.titleIcon) {
                    titleContent = `${renderIcon(config.titleIcon)} ${config.title}`;
                }
                html += `<div class="stats-card-header">${titleContent}</div>`;
            }

            // Body with stats
            if (config.stats && config.stats.length > 0) {
                html += '<div class="stats-card-body">';
                config.stats.forEach(stat => {
                    html += '<div class="stats-card-row">';
                    html += `<div class="stats-card-label">`;
                    if (stat.icon) {
                        html += `<span class="stats-card-icon">${renderIcon(stat.icon)}</span>`;
                    }
                    html += `<span>${stat.label}</span>`;
                    html += '</div>';
                    html += `<div class="stats-card-value">${stat.value}</div>`;
                    html += '</div>';
                });
                html += '</div>';
            }

            // Footer
            if (config.footer) {
                html += `<div class="stats-card-footer">${config.footer}</div>`;
            }

            return html;
        };

        // Determine data source - R2 or local with fallback
        const primaryUrl = window.CONFIG?.R2_DATA_URL || './steps_data.json';
        const fallbackUrl = './steps_data.json';
        
        const fetchData = (url) => fetch(url + '?t=' + Date.now()).then(r => r.json());
        
        // Try R2 first, fall back to local if it fails
        const dataPromise = primaryUrl !== fallbackUrl ? 
            fetchData(primaryUrl).catch(err => {
                console.log('R2 fetch failed, falling back to local data:', err.message);
                return fetchData(fallbackUrl);
            }) :
            fetchData(primaryUrl);
            
        dataPromise.then(jsonData => {
            // Handle new structure with metadata, or legacy flat structure
            let data, lastUpdated;
            if (jsonData && typeof jsonData === 'object' && 'data' in jsonData && 'metadata' in jsonData) {
                // New structure
                data = jsonData.data;
                lastUpdated = jsonData.metadata.lastUpdated ? new Date(jsonData.metadata.lastUpdated) : null;
            } else {
                // Legacy structure - treat entire content as data
                data = jsonData;
                lastUpdated = null;
            }
            // Convert data to array format expected by cal-heatmap
            // Handle both old format (integer) and new format (object with steps and km)
            const chartData = [];
            Object.keys(data).forEach(dateStr => {
                const entry = data[dateStr];
                const steps = typeof entry === 'object' ? entry.steps : entry;
                chartData.push({
                    date: dateStr,
                    value: steps,
                    km: typeof entry === 'object' ? entry.km : 0
                });
            });

            // Ensure today's date is in chartData even if not in data yet
            // This ensures current day shows the legend's 0-step color instead of empty/black
            const todayInTz = dayjs().tz(window.CONFIG?.TIMEZONE || dayjs.tz.guess());
            const todayStr = todayInTz.format('YYYY-MM-DD');
            const todayYear = todayInTz.year();

            // Only add today if it's not already in the data and is within 2026
            if (!data[todayStr] && todayYear === 2026) {
                chartData.push({
                    date: todayStr,
                    value: 0,
                    km: 0
                });
            }

            // Find the day with max steps for highlighting
            let maxSteps = 0;
            let maxStepDate = null;
            chartData.forEach(item => {
                if (item.value > maxSteps) {
                    maxSteps = item.value;
                    maxStepDate = item.date;
                }
            });

            // Calculate monthly totals for tooltips
            const monthlyTotals = {};
            chartData.forEach(item => {
                const monthKey = item.date.substring(0, 7); // Get YYYY-MM
                if (!monthlyTotals[monthKey]) {
                    monthlyTotals[monthKey] = { steps: 0, km: 0, maxDay: null, maxSteps: 0 };
                }
                monthlyTotals[monthKey].steps += item.value;
                monthlyTotals[monthKey].km += item.km;

                // Track the day with the most steps
                if (item.value > monthlyTotals[monthKey].maxSteps) {
                    monthlyTotals[monthKey].maxSteps = item.value;
                    monthlyTotals[monthKey].maxDay = item.date;
                }
            });

            let total = 0, totalKm = 0, streak = 0, active = true;
            let streakStartDate = null, streakEndDate = null;
            let today = new Date(); today.setHours(0,0,0,0);
            let dayCount = Object.keys(data).length;
            let daysWithGoal = 0; // Count days that hit 10k+

            Object.keys(data).sort().reverse().forEach(dateStr => {
                const entry = data[dateStr];
                let steps = typeof entry === 'object' ? entry.steps : entry;
                let km = typeof entry === 'object' ? entry.km : 0;
                total += steps;
                totalKm += km;

                // Count days with 10k+ steps
                if (steps >= 10000) {
                    daysWithGoal++;
                }

                let date = new Date(dateStr + 'T00:00:00'); date.setHours(0,0,0,0);
                if (active && date <= today) {
                    if (steps >= 10000) {
                        streak++;
                        if (streakEndDate === null) streakEndDate = dateStr; // First day we encounter (most recent)
                        streakStartDate = dateStr; // Keep updating to get the earliest day
                    } else if (date.getTime() !== today.getTime()) {
                        active = false;
                    }
                }
            });

            const dailyAverage = dayCount > 0 ? Math.round(total / dayCount) : 0;
            const averageKm = dayCount > 0 ? (totalKm / dayCount).toFixed(1) : 0;

            // Calculate day of year (1-366)
            const yearStart = new Date(2026, 0, 1);
            const dayOfYear = Math.ceil((today - yearStart) / (1000 * 60 * 60 * 24)) + 1;
            const goalPercentage = dayOfYear > 0 ? Math.round((daysWithGoal / dayOfYear) * 100) : 0;

            document.getElementById("total-steps").innerText = fmt(total);
            document.getElementById("daily-average").innerText = fmt(dailyAverage);
            document.getElementById("current-streak").innerText = streak;
            document.getElementById("goal-percentage").innerText = goalPercentage + "%";

            // Trigger fade-in animation for stats
            document.querySelector('.stats').classList.add('loaded');

            // Calculate and display last updated time based on metadata timestamp
            if (lastUpdated) {
                const now = new Date();
                const diffMs = now - lastUpdated;
                const diffMinutes = Math.floor(diffMs / (1000 * 60));
                const diffHours = Math.floor(diffMinutes / 60);
                const diffDays = Math.floor(diffHours / 24);

                let timeAgo;
                if (diffMinutes < 1) {
                    timeAgo = "just now";
                } else if (diffMinutes < 60) {
                    timeAgo = diffMinutes === 1 ? "1 minute ago" : diffMinutes + " minutes ago";
                } else if (diffHours < 24) {
                    timeAgo = diffHours === 1 ? "1 hour ago" : diffHours + " hours ago";
                } else if (diffDays === 1) {
                    timeAgo = "yesterday";
                } else {
                    timeAgo = diffDays + " days ago";
                }

                document.getElementById("last-updated").innerText = "Last updated: " + timeAgo;
            }

            // Get responsive cell configuration based on screen size
            const cellConfig = getResponsiveCellConfig();

            cal.paint(
                {
                    data: {
                        source: chartData,
                        x: 'date',
                        y: 'value',
                    },
                    date: { start: new Date('2026-01-01') },
                    range: 12,
                    scale: {
                        color: {
                            type: 'threshold',
                            range: ['#14432a', '#166b34', '#37a446', '#4dd05a'],
                            domain: [3000, 6000, 10000],
                        },
                    },
                    domain: {
                        type: 'month',
                        gutter: cellConfig.gutter,
                        label: { text: 'MMM', textAlign: 'middle', position: 'top' },
                    },
                    subDomain: {
                        type: 'ghDay',
                        radius: 2,
                        width: cellConfig.width,
                        height: cellConfig.height,
                        gutter: cellConfig.gutter,
                        empty: '#000000'
                    },
                    itemSelector: '#cal-heatmap',
                }
            );

            cal.on('click', function(event, timestamp, value) {
                console.log('Clicked:', timestamp, value);
                
                // Track heatmap cell interactions
                if (window.goatcounter && window.goatcounter.count && value > 0) {
                    const clickedDate = new Date(timestamp);
                    const dateStr = dayjs(clickedDate)
                        .tz(window.CONFIG?.TIMEZONE || dayjs.tz.guess())
                        .format('YYYY-MM-DD');
                    
                    let stepCategory = 'low-steps'; // 0-2999
                    if (value >= 10000) stepCategory = 'goal-achieved';
                    else if (value >= 6000) stepCategory = 'moderate-steps';
                    else if (value >= 3000) stepCategory = 'low-moderate-steps';
                    
                    window.goatcounter.count({
                        path: `heatmap-cell-clicked-${stepCategory}`,
                        title: `Heatmap Cell Clicked: ${value} steps (${stepCategory})`,
                        event: true
                    });
                }
            });

            // Wait for calendar to render and add blackout styling + a reliable custom tooltip
            setTimeout(() => {
                // Hide loading skeleton and show actual heatmap with fade-in
                const skeleton = document.getElementById('loading-skeleton');
                const heatmap = document.getElementById('cal-heatmap');
                const legend = document.querySelector('.legend');
                const lastUpdated = document.querySelector('.last-updated');

                if (skeleton) skeleton.classList.add('hidden');
                if (heatmap) heatmap.classList.add('loaded');
                if (legend) legend.classList.add('loaded');
                if (lastUpdated) lastUpdated.classList.add('loaded');

                const tooltipEl = document.getElementById('step-tooltip');

                const yearStart = new Date(2026, 0, 1);
                const yearEnd = new Date(2026, 11, 31);

                const formatDate = (d) => d.toLocaleDateString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                });

                const updateTooltipPosition = (evt) => {
                    const offset = 12;
                    const padding = 8; // Padding from viewport edges

                    // Get tooltip dimensions (need to show it first to measure)
                    const tooltipRect = tooltipEl.getBoundingClientRect();
                    const tooltipWidth = tooltipRect.width;
                    const tooltipHeight = tooltipRect.height;

                    // Get viewport dimensions
                    const viewportWidth = window.innerWidth;
                    const viewportHeight = window.innerHeight;

                    // Calculate initial position (bottom-right of cursor)
                    let left = evt.clientX + offset;
                    let top = evt.clientY + offset;

                    // Check if tooltip overflows right edge
                    if (left + tooltipWidth + padding > viewportWidth) {
                        // Position to the left of cursor instead
                        left = evt.clientX - tooltipWidth - offset;
                        // Ensure it doesn't overflow left edge
                        if (left < padding) {
                            left = padding;
                        }
                    }

                    // Check if tooltip overflows bottom edge
                    if (top + tooltipHeight + padding > viewportHeight) {
                        // Position above cursor instead
                        top = evt.clientY - tooltipHeight - offset;
                        // Ensure it doesn't overflow top edge
                        if (top < padding) {
                            top = padding;
                        }
                    }

                    // Apply final position
                    tooltipEl.style.left = `${left}px`;
                    tooltipEl.style.top = `${top}px`;
                };

                const showTooltip = (html, evt) => {
                    tooltipEl.innerHTML = html;
                    tooltipEl.style.display = 'block';
                    tooltipEl.setAttribute('aria-hidden', 'false');
                    updateTooltipPosition(evt);
                    // Initialize Lucide icons in the tooltip
                    if (window.lucide) {
                        lucide.createIcons();
                    }
                };

                const hideTooltip = () => {
                    tooltipEl.style.display = 'none';
                    tooltipEl.setAttribute('aria-hidden', 'true');
                };

                const cells = document.querySelectorAll('#cal-heatmap rect.ch-subdomain-bg');
                console.log('Found subdomain cells:', cells.length);

                // Pre-index data for O(1) lookup - store full entry with km
                const dataByDate = new Map(chartData.map(d => [d.date, { steps: d.value, km: d.km }]));

                cells.forEach((cell) => {
                    // Cal-Heatmap binds a datum per cell (D3). Use that timestamp for correct date mapping.
                    const d = (typeof d3 !== 'undefined') ? d3.select(cell).datum() : null;
                    const cellDate = d?.t ? new Date(d.t) : null;
                    if (!cellDate) return;
                    cellDate.setHours(0,0,0,0);

                    // Use local date (CONFIG.TIMEZONE) for matching steps_data.json keys.
                    const dateStr = dayjs(cellDate)
                        .tz(window.CONFIG?.TIMEZONE || dayjs.tz.guess())
                        .format('YYYY-MM-DD');
                    const isBeforeYear = cellDate < yearStart;
                    const isAfterYear = cellDate > yearEnd;

                    if (isBeforeYear || isAfterYear) {
                        cell.style.fill = '#0d1117';
                        cell.style.opacity = '1.0';
                        // Keep a title as a fallback, but rely on custom tooltip for consistency
                        cell.setAttribute('title', 'Outside year range');
                        cell.style.pointerEvents = 'none';
                        return;
                    }

                    // Check if date is in the future - disable tooltips for future dates
                    const todayDate = new Date();
                    todayDate.setHours(0,0,0,0);
                    const isFutureDate = cellDate > todayDate;

                    const dayData = dataByDate.get(dateStr) ?? { steps: 0, km: 0 };
                    const steps = dayData.steps;
                    const km = dayData.km;
                    const isMaxDay = dateStr === maxStepDate;

                    // Build tooltip using StatsCard component
                    const statsArray = [];

                    // Add steps stat
                    statsArray.push({
                        icon: 'footprints',
                        label: 'Steps',
                        value: steps ? fmt(steps) : 'No steps'
                    });

                    // Add distance stat if available
                    if (km > 0) {
                        statsArray.push({
                            icon: 'map-pin',
                            label: 'Distance',
                            value: `${km} km`
                        });
                    }

                    // Add personal best badge for max day
                    if (isMaxDay) {
                        statsArray.push({
                            icon: 'trophy',
                            label: 'Personal Best',
                            value: ''
                        });
                    }

                    const tooltipHtml = renderStatsCard({
                        title: formatDate(cellDate),
                        titleIcon: null,
                        stats: statsArray
                    });

                    // Highlight max step day with a gold outline (SVG-friendly)
                    if (isMaxDay) {
                        cell.classList.add('is-max-day');
                        // Set explicitly too (helps if styles get overridden by library updates)
                        cell.setAttribute('stroke', '#ffd700');
                        cell.setAttribute('stroke-width', '2');
                        cell.setAttribute('paint-order', 'stroke');
                        // Avoid glow/shadows here because SVG may clip filters at the cell bounds

                        // Add confetti celebration on click
                        cell.style.cursor = 'pointer';
                        cell.addEventListener('click', (evt) => {
                            const rect = cell.getBoundingClientRect();
                            const x = (rect.left + rect.width / 2) / window.innerWidth;
                            const y = (rect.top + rect.height / 2) / window.innerHeight;

                            // Track personal best interaction
                            if (window.goatcounter && window.goatcounter.count) {
                                window.goatcounter.count({
                                    path: 'personal-best-clicked',
                                    title: `Personal Best Day Clicked: ${steps} steps on ${formatDate(cellDate)}`,
                                    event: true
                                });
                            }

                            confetti({
                                particleCount: 100,
                                spread: 70,
                                origin: { x, y },
                                colors: ['#ffd700', '#ffed4e', '#ffaa00', '#ff8800'],
                                ticks: 200,
                                gravity: 1.2,
                                scalar: 1.2
                            });
                        });
                    }

                    // Skip tooltips for future dates
                    if (isFutureDate) {
                        return;
                    }

                    // Fallback title (some environments still show this) - use plain text
                    const plainTextTitle = `${isMaxDay ? 'Personal Best! ' : ''}${steps ? fmt(steps) : 'No'} steps${km > 0 ? ` (${km} km)` : ''} on ${formatDate(cellDate)}`;
                    cell.setAttribute('title', plainTextTitle);

                    // Custom tooltip handlers
                    cell.addEventListener('mouseenter', (evt) => showTooltip(tooltipHtml, evt));
                    cell.addEventListener('mousemove', updateTooltipPosition);
                    cell.addEventListener('mouseleave', hideTooltip);
                });

                // If you leave the SVG entirely, hide tooltip
                const svg = document.querySelector('#cal-heatmap svg');
                if (svg) svg.addEventListener('mouseleave', hideTooltip);

                // Add tooltips for month labels
                const monthLabels = document.querySelectorAll('#cal-heatmap .ch-domain-text');
                console.log('Found month labels:', monthLabels.length);

                monthLabels.forEach((label, index) => {
                    // Calculate which month this label represents (0-indexed, starting from January 2026)
                    const monthIndex = index; // 0 = Jan, 1 = Feb, etc.
                    const year = 2026;
                    const monthKey = `${year}-${String(monthIndex + 1).padStart(2, '0')}`; // Format: YYYY-MM

                    // Check if this month has data
                    const monthData = monthlyTotals[monthKey];

                    if (monthData && monthData.steps > 0) {
                        // This month has steps data, add tooltip
                        const monthName = new Date(year, monthIndex, 1).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });

                        // Build stats array for the month
                        const monthStats = [
                            {
                                icon: 'footprints',
                                label: 'Total Steps',
                                value: fmt(monthData.steps)
                            },
                            {
                                icon: 'map-pin',
                                label: 'Total Distance',
                                value: `${monthData.km.toFixed(1)} km`
                            }
                        ];

                        // Add day with most steps if available
                        if (monthData.maxDay && monthData.maxSteps > 0) {
                            const maxDayDate = new Date(monthData.maxDay + 'T00:00:00');
                            const maxDayFormatted = maxDayDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                            monthStats.push({
                                icon: 'trophy',
                                label: 'Best Day',
                                value: `${maxDayFormatted} (${fmt(monthData.maxSteps)} steps)`
                            });
                        }

                        const monthTooltipHtml = renderStatsCard({
                            title: monthName,
                            titleIcon: 'calendar',
                            stats: monthStats
                        });

                        label.addEventListener('mouseenter', (evt) => {
                            // Track month tooltip interaction
                            if (window.goatcounter && window.goatcounter.count) {
                                window.goatcounter.count({
                                    path: 'month-tooltip-viewed',
                                    title: `Month Tooltip Viewed: ${monthName}`,
                                    event: true
                                });
                            }
                            showTooltip(monthTooltipHtml, evt);
                        });
                        label.addEventListener('mousemove', updateTooltipPosition);
                        label.addEventListener('mouseleave', hideTooltip);
                        label.style.cursor = 'help';
                    }
                });

                // Add tooltips for Total Steps and Daily Average stats
                const totalStepsEl = document.getElementById('total-steps');
                const dailyAverageEl = document.getElementById('daily-average');
                const streakEl = document.getElementById('current-streak');

                if (totalStepsEl) {
                    const totalStepsTooltipHtml = renderStatsCard({
                        title: 'Total Steps',
                        stats: [
                            {
                                icon: 'footprints',
                                label: 'Steps',
                                value: fmt(total)
                            },
                            {
                                icon: 'map-pin',
                                label: 'Distance',
                                value: `${totalKm.toFixed(1)} km`
                            }
                        ]
                    });
                    totalStepsEl.addEventListener('mouseenter', (evt) => {
                        // Track total steps tooltip interaction
                        if (window.goatcounter && window.goatcounter.count) {
                            window.goatcounter.count({
                                path: 'stat-tooltip-total-steps',
                                title: 'Total Steps Tooltip Viewed',
                                event: true
                            });
                        }
                        showTooltip(totalStepsTooltipHtml, evt);
                    });
                    totalStepsEl.addEventListener('mousemove', updateTooltipPosition);
                    totalStepsEl.addEventListener('mouseleave', hideTooltip);
                    totalStepsEl.style.cursor = 'help';
                }

                if (dailyAverageEl) {
                    const dailyAverageTooltipHtml = renderStatsCard({
                        title: 'Daily Average',
                        stats: [
                            {
                                icon: 'bar-chart-3',
                                label: 'Steps per day',
                                value: fmt(dailyAverage)
                            },
                            {
                                icon: 'map-pin',
                                label: 'Distance per day',
                                value: `${averageKm} km`
                            }
                        ]
                    });
                    dailyAverageEl.addEventListener('mouseenter', (evt) => {
                        // Track daily average tooltip interaction
                        if (window.goatcounter && window.goatcounter.count) {
                            window.goatcounter.count({
                                path: 'stat-tooltip-daily-average',
                                title: 'Daily Average Tooltip Viewed',
                                event: true
                            });
                        }
                        showTooltip(dailyAverageTooltipHtml, evt);
                    });
                    dailyAverageEl.addEventListener('mousemove', updateTooltipPosition);
                    dailyAverageEl.addEventListener('mouseleave', hideTooltip);
                    dailyAverageEl.style.cursor = 'help';
                }

                if (streakEl && streak > 0 && streakStartDate && streakEndDate) {
                    const formatStreakDate = (dateStr) => {
                        const date = new Date(dateStr + 'T00:00:00');
                        return date.toLocaleDateString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            year: 'numeric'
                        });
                    };

                    let dateRange;
                    if (streakStartDate === streakEndDate) {
                        // Single day streak
                        dateRange = formatStreakDate(streakStartDate);
                    } else {
                        // Multi-day streak
                        dateRange = `${formatStreakDate(streakStartDate)} - ${formatStreakDate(streakEndDate)}`;
                    }

                    const streakTooltipHtml = renderStatsCard({
                        title: '10k+ Streak',
                        stats: [
                            {
                                icon: 'flame',
                                label: 'Current streak',
                                value: `${streak} ${streak === 1 ? 'day' : 'days'}`
                            },
                            {
                                icon: 'calendar',
                                label: 'Period',
                                value: dateRange
                            }
                        ]
                    });

                    streakEl.addEventListener('mouseenter', (evt) => {
                        // Track streak tooltip interaction
                        if (window.goatcounter && window.goatcounter.count) {
                            window.goatcounter.count({
                                path: 'stat-tooltip-streak',
                                title: `Streak Tooltip Viewed: ${streak} day streak`,
                                event: true
                            });
                        }
                        showTooltip(streakTooltipHtml, evt);
                    });
                    streakEl.addEventListener('mousemove', updateTooltipPosition);
                    streakEl.addEventListener('mouseleave', hideTooltip);
                    streakEl.style.cursor = 'help';
                }

                const goalPercentageEl = document.getElementById('goal-percentage');
                if (goalPercentageEl) {
                    const goalPercentageTooltipHtml = renderStatsCard({
                        title: 'Adherence Score',
                        stats: [
                            {
                                icon: 'check-circle',
                                label: 'Days with 10k+',
                                value: `${daysWithGoal} days`
                            },
                            {
                                icon: 'calendar',
                                label: 'Day of Year',
                                value: `Day ${dayOfYear}`
                            },
                            {
                                icon: 'percent',
                                label: 'Adherence',
                                value: `${goalPercentage}%`
                            }
                        ]
                    });
                    goalPercentageEl.addEventListener('mouseenter', (evt) => {
                        // Track goal percentage tooltip interaction
                        if (window.goatcounter && window.goatcounter.count) {
                            window.goatcounter.count({
                                path: 'stat-tooltip-goal-percentage',
                                title: 'Goal Percentage Tooltip Viewed',
                                event: true
                            });
                        }
                        showTooltip(goalPercentageTooltipHtml, evt);
                    });
                    goalPercentageEl.addEventListener('mousemove', updateTooltipPosition);
                    goalPercentageEl.addEventListener('mouseleave', hideTooltip);
                    goalPercentageEl.style.cursor = 'help';
                }

            }, 500);
        });
    </script>
</body>
</html>
