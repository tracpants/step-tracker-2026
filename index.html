<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Step Tracker</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/dayjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/plugin/utc.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dayjs@1.11.10/plugin/timezone.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cal-heatmap@4.2.4/dist/cal-heatmap.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cal-heatmap@4.2.4/dist/cal-heatmap.css">
    <script src="https://cdn.jsdelivr.net/npm/cal-heatmap@4.2.4/dist/plugins/CalendarLabel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <script>
        // Skip GoatCounter tracking for development environments
        if (window.location.hostname === 'localhost' || 
            window.location.hostname === '127.0.0.1' || 
            window.location.hostname.includes('192.168.') ||
            window.location.hostname.includes('10.0.') ||
            window.location.hash === '#toggle-goatcounter') {
            window.goatcounter = {no_onload: true};
        }
    </script>
    <script data-goatcounter="https://normal-past.goatcounter.com/count"
            async src="//gc.zgo.at/count.js"></script>
    <script src="./config.js"></script>
    <style>
        body { font-family: system-ui, sans-serif; background: #0d1117; color: #c9d1d9; margin: 0; padding: 20px; }
        .container { max-width: 800px; margin: 0 auto; text-align: center; }
        .stats { display: flex; gap: 30px; justify-content: center; margin: 20px 0; }
        .stat { font-size: 24px; font-weight: bold; }
        .label { font-size: 12px; color: #8b949e; }
        #cal-heatmap { margin: 20px 0; }

        /* Add breathing room so SVG strokes (e.g., max-day outline) don't get clipped at edges */
        #cal-heatmap svg {
            overflow: visible;
        }
        /* Cal-Heatmap positions content tightly; this wrapper padding helps first/last column strokes */
        #cal-heatmap {
            padding: 3px;
            margin: 17px auto; /* keep roughly the same visual spacing as 20px */
            display: inline-block;
        }

        /* SVG-friendly highlight for the max-step day (box-shadow doesn't apply to SVG rects) */
        #cal-heatmap rect.is-max-day {
            stroke: #ffd700;
            stroke-width: 2px;
            /* ensure stroke is drawn clearly on top of the fill */
            paint-order: stroke;
            /* keep stroke sizing stable */
            vector-effect: non-scaling-stroke;
        }

        /* Custom tooltip (more reliable than SVG <title> tooltips across browsers) */
        #step-tooltip {
            position: fixed;
            z-index: 9999;
            pointer-events: none;
            display: none;
            max-width: 300px;
            padding: 8px 10px;
            border: 1px solid #30363d;
            border-radius: 6px;
            background: #161b22;
            color: #c9d1d9;
            font-size: 12px;
            line-height: 1.5;
            box-shadow: 0 8px 24px rgba(0,0,0,0.45);
        }

        /* Legend styling */
        .legend {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 4px;
            margin-top: 10px;
            font-size: 12px;
        }

        .legend-text {
            color: #768390;
        }

        .legend-colors {
            display: flex;
            gap: 2px;
        }

        .legend-box {
            width: 10px;
            height: 10px;
            border-radius: 1px;
        }
    </style>
</head>
<body>
    <div class="container">
              
        <div class="stats">
            <div>
                <div class="stat" id="total-steps">-</div>
                <div class="label">Total Steps</div>
            </div>
            <div>
                <div class="stat" id="daily-average">-</div>
                <div class="label">Daily Average</div>
            </div>
            <div>
                <div class="stat" id="current-streak">-</div>
                <div class="label">10k+ Streak</div>
            </div>
        </div>

        <div id="cal-heatmap"></div>
        
        <div class="legend">
            <span class="legend-text">0</span>
            <div class="legend-colors">
                <div class="legend-box" style="background-color: #14432a;"></div>
                <div class="legend-box" style="background-color: #166b34;"></div>
                <div class="legend-box" style="background-color: #37a446;"></div>
                <div class="legend-box" style="background-color: #4dd05a;"></div>
            </div>
            <span class="legend-text">10k+</span>
        </div>

        <div class="label" id="last-updated" style="margin-top: 15px;">Last updated: -</div>
    </div>

    <div id="step-tooltip" role="tooltip" aria-hidden="true"></div>

    <script>
        dayjs.extend(dayjs_plugin_utc);
        dayjs.extend(dayjs_plugin_timezone);

        const fmt = (n) => n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        const cal = new CalHeatmap();
        
        fetch('./steps_data.json?t=' + Date.now()).then(r => {
            return r.json();
        }).then(jsonData => {
            // Handle new structure with metadata, or legacy flat structure
            let data, lastUpdated;
            if (jsonData && typeof jsonData === 'object' && 'data' in jsonData && 'metadata' in jsonData) {
                // New structure
                data = jsonData.data;
                lastUpdated = jsonData.metadata.lastUpdated ? new Date(jsonData.metadata.lastUpdated) : null;
            } else {
                // Legacy structure - treat entire content as data
                data = jsonData;
                lastUpdated = null;
            }
            // Convert data to array format expected by cal-heatmap
            // Handle both old format (integer) and new format (object with steps and km)
            const chartData = [];
            Object.keys(data).forEach(dateStr => {
                const entry = data[dateStr];
                const steps = typeof entry === 'object' ? entry.steps : entry;
                chartData.push({
                    date: dateStr,
                    value: steps,
                    km: typeof entry === 'object' ? entry.km : 0
                });
            });

            // Find the day with max steps for highlighting
            let maxSteps = 0;
            let maxStepDate = null;
            chartData.forEach(item => {
                if (item.value > maxSteps) {
                    maxSteps = item.value;
                    maxStepDate = item.date;
                }
            });

            let total = 0, totalKm = 0, streak = 0, active = true;
            let streakStartDate = null, streakEndDate = null;
            let today = new Date(); today.setHours(0,0,0,0);
            let dayCount = Object.keys(data).length;

            Object.keys(data).sort().reverse().forEach(dateStr => {
                const entry = data[dateStr];
                let steps = typeof entry === 'object' ? entry.steps : entry;
                let km = typeof entry === 'object' ? entry.km : 0;
                total += steps;
                totalKm += km;

                let date = new Date(dateStr + 'T00:00:00'); date.setHours(0,0,0,0);
                if (active && date <= today) {
                    if (steps >= 10000) {
                        streak++;
                        if (streakEndDate === null) streakEndDate = dateStr; // First day we encounter (most recent)
                        streakStartDate = dateStr; // Keep updating to get the earliest day
                    } else if (date.getTime() !== today.getTime()) {
                        active = false;
                    }
                }
            });

            const dailyAverage = dayCount > 0 ? Math.round(total / dayCount) : 0;
            const averageKm = dayCount > 0 ? (totalKm / dayCount).toFixed(1) : 0;

            document.getElementById("total-steps").innerText = fmt(total);
            document.getElementById("daily-average").innerText = fmt(dailyAverage);
            document.getElementById("current-streak").innerText = streak;

            // Calculate and display last updated time based on metadata timestamp
            if (lastUpdated) {
                const now = new Date();
                const diffMs = now - lastUpdated;
                const diffMinutes = Math.floor(diffMs / (1000 * 60));
                const diffHours = Math.floor(diffMinutes / 60);
                const diffDays = Math.floor(diffHours / 24);

                let timeAgo;
                if (diffMinutes < 1) {
                    timeAgo = "just now";
                } else if (diffMinutes < 60) {
                    timeAgo = diffMinutes === 1 ? "1 minute ago" : diffMinutes + " minutes ago";
                } else if (diffHours < 24) {
                    timeAgo = diffHours === 1 ? "1 hour ago" : diffHours + " hours ago";
                } else if (diffDays === 1) {
                    timeAgo = "yesterday";
                } else {
                    timeAgo = diffDays + " days ago";
                }

                document.getElementById("last-updated").innerText = "Last updated: " + timeAgo;
            }

            cal.paint(
                {
                    data: {
                        source: chartData,
                        x: 'date',
                        y: 'value',
                    },
                    date: { start: new Date('2026-01-01') },
                    range: 12,
                    scale: {
                        color: {
                            type: 'threshold',
                            range: ['#14432a', '#166b34', '#37a446', '#4dd05a'],
                            domain: [3000, 6000, 10000],
                        },
                    },
                    domain: {
                        type: 'month',
                        gutter: 4,
                        label: { text: 'MMM', textAlign: 'middle', position: 'top' },
                    },
                    subDomain: { type: 'ghDay', radius: 2, width: 11, height: 11, gutter: 4, empty: '#000000' },
                    itemSelector: '#cal-heatmap',
                }
            );

            cal.on('click', function(event, timestamp, value) {
                console.log('Clicked:', timestamp, value);
                
                // Track heatmap cell interactions
                if (window.goatcounter && window.goatcounter.count && value > 0) {
                    const clickedDate = new Date(timestamp);
                    const dateStr = dayjs(clickedDate)
                        .tz(window.CONFIG?.TIMEZONE || dayjs.tz.guess())
                        .format('YYYY-MM-DD');
                    
                    let stepCategory = 'low-steps'; // 0-2999
                    if (value >= 10000) stepCategory = 'goal-achieved';
                    else if (value >= 6000) stepCategory = 'moderate-steps';
                    else if (value >= 3000) stepCategory = 'low-moderate-steps';
                    
                    window.goatcounter.count({
                        path: `heatmap-cell-clicked-${stepCategory}`,
                        title: `Heatmap Cell Clicked: ${value} steps (${stepCategory})`,
                        event: true
                    });
                }
            });

            // Wait for calendar to render and add blackout styling + a reliable custom tooltip
            setTimeout(() => {
                const tooltipEl = document.getElementById('step-tooltip');

                const yearStart = new Date(2026, 0, 1);
                const yearEnd = new Date(2026, 11, 31);

                const formatDate = (d) => d.toLocaleDateString('en-US', {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric',
                });

                const updateTooltipPosition = (evt) => {
                    const offset = 12;
                    tooltipEl.style.left = `${evt.clientX + offset}px`;
                    tooltipEl.style.top = `${evt.clientY + offset}px`;
                };

                const showTooltip = (text, evt) => {
                    tooltipEl.textContent = text;
                    tooltipEl.style.display = 'block';
                    tooltipEl.setAttribute('aria-hidden', 'false');
                    updateTooltipPosition(evt);
                };

                const hideTooltip = () => {
                    tooltipEl.style.display = 'none';
                    tooltipEl.setAttribute('aria-hidden', 'true');
                };

                const cells = document.querySelectorAll('#cal-heatmap rect.ch-subdomain-bg');
                console.log('Found subdomain cells:', cells.length);

                // Pre-index data for O(1) lookup - store full entry with km
                const dataByDate = new Map(chartData.map(d => [d.date, { steps: d.value, km: d.km }]));

                cells.forEach((cell) => {
                    // Cal-Heatmap binds a datum per cell (D3). Use that timestamp for correct date mapping.
                    const d = (typeof d3 !== 'undefined') ? d3.select(cell).datum() : null;
                    const cellDate = d?.t ? new Date(d.t) : null;
                    if (!cellDate) return;
                    cellDate.setHours(0,0,0,0);

                    // Use local date (CONFIG.TIMEZONE) for matching steps_data.json keys.
                    const dateStr = dayjs(cellDate)
                        .tz(window.CONFIG?.TIMEZONE || dayjs.tz.guess())
                        .format('YYYY-MM-DD');
                    const isBeforeYear = cellDate < yearStart;
                    const isAfterYear = cellDate > yearEnd;

                    if (isBeforeYear || isAfterYear) {
                        cell.style.fill = '#000000';
                        cell.style.opacity = '0.3';
                        // Keep a title as a fallback, but rely on custom tooltip for consistency
                        cell.setAttribute('title', 'Outside year range');
                        cell.style.pointerEvents = 'none';
                        return;
                    }

                    // Check if date is in the future - disable tooltips for future dates
                    const todayDate = new Date();
                    todayDate.setHours(0,0,0,0);
                    const isFutureDate = cellDate > todayDate;

                    const dayData = dataByDate.get(dateStr) ?? { steps: 0, km: 0 };
                    const steps = dayData.steps;
                    const km = dayData.km;
                    const isMaxDay = dateStr === maxStepDate;

                    // Build tooltip text with steps and km
                    let tooltipText = `${isMaxDay ? 'ðŸ† Personal Best! ' : ''}${steps ? fmt(steps) : 'No'} steps`;
                    if (km > 0) {
                        tooltipText += ` (${km} km)`;
                    }
                    tooltipText += ` on ${formatDate(cellDate)}`;

                    // Highlight max step day with a gold outline (SVG-friendly)
                    if (isMaxDay) {
                        cell.classList.add('is-max-day');
                        // Set explicitly too (helps if styles get overridden by library updates)
                        cell.setAttribute('stroke', '#ffd700');
                        cell.setAttribute('stroke-width', '2');
                        cell.setAttribute('paint-order', 'stroke');
                        // Avoid glow/shadows here because SVG may clip filters at the cell bounds

                        // Add confetti celebration on click
                        cell.style.cursor = 'pointer';
                        cell.addEventListener('click', (evt) => {
                            const rect = cell.getBoundingClientRect();
                            const x = (rect.left + rect.width / 2) / window.innerWidth;
                            const y = (rect.top + rect.height / 2) / window.innerHeight;

                            // Track personal best interaction
                            if (window.goatcounter && window.goatcounter.count) {
                                window.goatcounter.count({
                                    path: 'personal-best-clicked',
                                    title: `Personal Best Day Clicked: ${steps} steps on ${formatDate(cellDate)}`,
                                    event: true
                                });
                            }

                            confetti({
                                particleCount: 100,
                                spread: 70,
                                origin: { x, y },
                                colors: ['#ffd700', '#ffed4e', '#ffaa00', '#ff8800'],
                                ticks: 200,
                                gravity: 1.2,
                                scalar: 1.2
                            });
                        });
                    }

                    // Skip tooltips for future dates
                    if (isFutureDate) {
                        return;
                    }

                    // Fallback title (some environments still show this)
                    cell.setAttribute('title', tooltipText);

                    // Custom tooltip handlers
                    cell.addEventListener('mouseenter', (evt) => showTooltip(tooltipText, evt));
                    cell.addEventListener('mousemove', updateTooltipPosition);
                    cell.addEventListener('mouseleave', hideTooltip);
                });

                // If you leave the SVG entirely, hide tooltip
                const svg = document.querySelector('#cal-heatmap svg');
                if (svg) svg.addEventListener('mouseleave', hideTooltip);

                // Add tooltips for Total Steps and Daily Average stats
                const totalStepsEl = document.getElementById('total-steps');
                const dailyAverageEl = document.getElementById('daily-average');
                const streakEl = document.getElementById('current-streak');

                if (totalStepsEl) {
                    const totalStepsTooltip = `${totalKm.toFixed(1)} km total`;
                    totalStepsEl.addEventListener('mouseenter', (evt) => {
                        // Track total steps tooltip interaction
                        if (window.goatcounter && window.goatcounter.count) {
                            window.goatcounter.count({
                                path: 'stat-tooltip-total-steps',
                                title: 'Total Steps Tooltip Viewed',
                                event: true
                            });
                        }
                        showTooltip(totalStepsTooltip, evt);
                    });
                    totalStepsEl.addEventListener('mousemove', updateTooltipPosition);
                    totalStepsEl.addEventListener('mouseleave', hideTooltip);
                    totalStepsEl.style.cursor = 'help';
                }

                if (dailyAverageEl) {
                    const dailyAverageTooltip = `${averageKm} km average per day`;
                    dailyAverageEl.addEventListener('mouseenter', (evt) => {
                        // Track daily average tooltip interaction
                        if (window.goatcounter && window.goatcounter.count) {
                            window.goatcounter.count({
                                path: 'stat-tooltip-daily-average',
                                title: 'Daily Average Tooltip Viewed',
                                event: true
                            });
                        }
                        showTooltip(dailyAverageTooltip, evt);
                    });
                    dailyAverageEl.addEventListener('mousemove', updateTooltipPosition);
                    dailyAverageEl.addEventListener('mouseleave', hideTooltip);
                    dailyAverageEl.style.cursor = 'help';
                }

                if (streakEl && streak > 0 && streakStartDate && streakEndDate) {
                    const formatStreakDate = (dateStr) => {
                        const date = new Date(dateStr + 'T00:00:00');
                        return date.toLocaleDateString('en-US', {
                            month: 'short',
                            day: 'numeric',
                            year: 'numeric'
                        });
                    };

                    let streakTooltip;
                    if (streakStartDate === streakEndDate) {
                        // Single day streak
                        streakTooltip = `${formatStreakDate(streakStartDate)}`;
                    } else {
                        // Multi-day streak
                        streakTooltip = `${formatStreakDate(streakStartDate)} - ${formatStreakDate(streakEndDate)}`;
                    }

                    streakEl.addEventListener('mouseenter', (evt) => {
                        // Track streak tooltip interaction
                        if (window.goatcounter && window.goatcounter.count) {
                            window.goatcounter.count({
                                path: 'stat-tooltip-streak',
                                title: `Streak Tooltip Viewed: ${streak} day streak`,
                                event: true
                            });
                        }
                        showTooltip(streakTooltip, evt);
                    });
                    streakEl.addEventListener('mousemove', updateTooltipPosition);
                    streakEl.addEventListener('mouseleave', hideTooltip);
                    streakEl.style.cursor = 'help';
                }
            }, 500);
        });
    </script>
</body>
</html>
